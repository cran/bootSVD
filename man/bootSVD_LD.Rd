\name{bootSVD_LD}
\alias{bootSVD_LD}
\title{Calculate bootstrap distribution of \eqn{n}-dimensional PCs}
\usage{
bootSVD_LD(UD, DUt = t(UD), bInds = genBootIndeces(B = 1000, n =
  dim(DUt)[2]), K, warning_type = "silent", talk = FALSE,
  centerSamples = TRUE)
}
\arguments{
  \item{UD}{a (\eqn{n} by \eqn{n}) matrix of scores, were
  rows denote individuals, and columns denote measurements
  in the PC space.}

  \item{DUt}{the transpose of \code{UD}. If both \code{UD}
  and \code{UDt} are entered and \code{t(UD)!=DUt}, the
  \code{DUt} argument will override the \code{UD}
  argument.}

  \item{bInds}{a (\eqn{B} by \eqn{n}) matrix of bootstrap
  indeces, where \code{B} is the number of bootstrap
  samples, and \code{n} is the sample size. Each row should
  be an indexing vector that can be used to generate a new
  bootstrap sample (i.e. \code{sample(n,replace=TRUE)}).
  The matrix of bootstrap indeces is taken as input, rather
  than being calculated within \code{bootSVD_LD}, so that
  this method can be more easily compared against
  traditional bootstrap SVD methods on the exact same
  bootstrap samples. The \code{bInds} matrix can be
  calculated using the helper function
  \code{\link{genBootIndeces}}).}

  \item{K}{the number of PCs to be estimated.}

  \item{warning_type}{passed to \code{\link{qrSVD}}, when
  taking the SVD of the low dimensional bootstrap score
  matrices.}

  \item{talk}{setting this to \code{TRUE} will cause a
  progress bar to appear.}

  \item{centerSamples}{whether each bootstrap sample should
  be centered before calculating the SVD.}
}
\value{
For each bootstrap matrix \eqn{(DU')^b}, let
\eqn{svd(DU')=:A^b D^b U^b}, where \eqn{A^b} and \eqn{U^b}
are (\eqn{n} by \eqn{n}) orthonormal matrices, and
\eqn{D^b} is a (\eqn{n} by \eqn{n}) diagonal matrix
\eqn{K}. Here we calculate only the first \code{K} columns
of \eqn{A^b}, but all \code{n} columns of \eqn{U^b}. The
results are stored as a list containing \item{As}{a
\code{B}-length list of the (\code{n} by \code{K}) matrices
containing the first \code{K} PCs from each bootstrap
sample. This list is indexed by \code{b}, with the
\eqn{b^{th}} element containing the results from the
\eqn{b^{th}} bootstrap sample.} \item{ds}{a \code{B}-length
list of vectors, indexed by the bootstrap index \code{b},
with each vector containing the singular values of the
corresponding bootstrap sample.} \item{Us}{a
\code{B}-length list, indexed by the bootstrap index
\code{b}, of the (\eqn{n} by \eqn{n}) matrices \eqn{U^b}.}
\item{time}{The computation time required for the
procedure, taken using \code{\link{system.time}}.} If the
score matrix is inputted to \code{bootSVD_LD}, the results
can be transformed to get the PCs on the original space by
multiplying each matrix \eqn{A^b} by the PCs of the
original sample, \eqn{V} (see \code{\link{As2Vs}}). The
bootstrap scores of the original sample are equal to
\eqn{U^b D^b}.
}
\description{
\code{bootSVD_LD} Calculates the bootstrap distribution of
the principal components (PCs) of a low dimensional matrix.
If the score matrix is inputted, the output of
\code{bootSVD_LD} can be used to to calculate bootstrap
standard errors, confidence regions, or the full bootstrap
distribution of the high dimensional components. Some users
may want to instead consider using \code{\link{bootSVD}},
which calls \code{bootSVD_LD}, and also calculates
descriptions of the high dimensional components.
}
\examples{
#use small n, small B for a quick illustration
set.seed(0)
Y<-simEEG(n=100, centered=TRUE, wide=TRUE)
svdY<-fastSVD(Y)
DUt<- tcrossprod(diag(svdY$d),svdY$u)
bInds<-genBootIndeces(B=200,n=dim(DUt)[2])
bootSVD_LD_output<-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,talk=TRUE)
}

